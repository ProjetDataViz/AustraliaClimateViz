<html>
    <head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <style>
.staterect {
    fill: rgba(15,30,150,0.33);
    stroke: #555;
}
text {
    font-family: sans-serif;
    font-size: 11px;
    fill: #333;
}
text.year {
    font-size: 24px;
    font-weight: 700;
    fill: #555;
}
input{
	border-radius:5px;
	padding:5px 10px;
	background:#999;
	border:0;
	color:#fff;
}
#inds{
	position:absolute;
	top:10px;
	left:10px;
}
.block{
      margin: 20px;
      display: inline-block;
    }
    .map{
      fill: steelblue;
      opacity: 0.5;
    }
    .line {
      fill: none;
      stroke-width: 1.5px;
    }
    circle{
    	stroke-width: 2px;  
    }
    .axis path, .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }
    .brushed {
      stroke: #8e1b54;
      opacity: 1.0;
    }
    .non_brushed {
      opacity: 0.7;
    }

  </style>
        <script>
            // show the given page, hide the rest
            function show(elementID) {
                // try to find the requested page and alert if it's not found
                var ele = document.getElementById(elementID);
                if (!ele) {
                    alert("no such element");
                    return;
                }

                // get all pages, loop through them and hide them
                var pages = document.getElementsByClassName('page');
                for(var i = 0; i < pages.length; i++) {
                    pages[i].style.display = 'none';
                }

                // then show the requested page
                ele.style.display = 'block';
		
            }
        </script>
    </head>
    <body>
      <p>
        Show page 
            <input type='radio' onclick="show('Page1');" name = "checkbox" >Humidity</span>,
            <input type='radio' onclick="show('Page2');" name = "checkbox" >Rainfall</span>, 
            <input type='radio' onclick="show('Page3');" name = "checkbox" >Température</span>
        </p>

    <div id="Page1" class="page" style="">
<p>HUMIDITY</p>

<script src="https://d3js.org/d3.v4.min.js"></script>  
<script>
var variable2 = 'humidity'
var interval = 2000
var maxSize = 123
  
var width = 981
var height = 508
var svg = d3.select('#Page1').append('svg')
    			.attr('width', width)
    			.attr('height', height)
    			.append('g') 

//L'ensemble des dates sur lesquelles seront récupérées les valeurs dans le json
var years2 = ['2008-été', '2009-automne', '2009-hiver',
       '2009-printemps', '2009-été', '2010-automne', '2010-hiver',
       '2010-printemps', '2010-été', '2011-automne', '2011-hiver',
       '2011-printemps', '2011-été', '2012-automne', '2012-hiver',
       '2012-printemps', '2012-été', '2013-automne', '2013-hiver',
       '2013-printemps', '2013-été', '2014-automne', '2014-hiver',
       '2014-printemps', '2014-été', '2015-automne', '2015-hiver',
       '2015-printemps', '2015-été', '2016-automne', '2016-hiver',
       '2016-printemps', '2016-été', '2017-automne', '2017-hiver',
       '2017-été']
var yearIndex2 = -1
var year2 = years2[0]    

//Définition des couleurs pour le remplissage des rectangles selon la densité de pop
var color = d3.scaleLinear().range(['#fee08b', '#d73027'])

//Définition de la projection, la map sur laquelle seront adaptées les coordonnées des territoires australiens
var projection2 = d3.geoConicConformal()
        .rotate([-132, 0])
        .center([0, -27])
        .parallels([-18, -36])
        .scale(Math.min(height * 1.2, width * 0.8))
        .translate([width / 2, height / 2])
        .precision(0.1);

//Taille des rectangles
var size2 = d3.scaleSqrt().range([0, maxSize])

//La date qui est  écrite sur la visualisation
var yearLabel2 = svg.append('text')
    .attr('class', 'year')
    .attr('x', width / 4.8)
    .attr('y', 29)
    .attr('text-anchor', 'middle')   


var mesure = 'var'  
  
//Définit la taille des links entre nodes (distance entre les rectangles)
var linkForce2 = d3.forceLink()
    .id(function (d) { return d.state })
    .distance(function (d) {
        return (
            size2(d.source[variable2].find(function (e) { return e.year === year2 })[mesure]) +
            size2(d.target[variable2].find(function (e) { return e.year === year2 })[mesure])
        ) / 1.6416
    })
    .strength(0.6)
    
//Collision entre les rectangles
var collisionForce2 = rectCollide()
    .size(function (d) {
        var l = size2(d[variable2].find(function (e) { return e.year === year2 })[mesure])
        return [l, l]
    })
    .iterations(63)

//Définition des paramètres de simulation
var simulation2 = d3.forceSimulation()
    .force('center', d3.forceCenter(width / 2.0608, (height - maxSize) / 2))
    .force('link', linkForce2)
    .force('collision', collisionForce2)
    .force('x', d3.forceX(function (d) { return d.xi }).strength(0.0125))
    .force('y', d3.forceY(function (d) { return d.yi }).strength(0.0125))

color.domain([0, 1219]);

//Si un autre item est sélectionné appel de la fonction change
d3.select("#label-option").on("change", change)

//Modifie la variable d'étude (température, humidity ou rainfall) de la fonction simulation

d3.json('data_humidity.txt', initialize)

function change() {
    if (this.selectedIndex == 0){
    simulation.stop()
    d3.json('data_temperature.txt', initialize)
    } else if (this.selectedIndex == 1){
    simulation.stop()
    d3.json('data_humidity', initialize)
    } else if (this.selectedIndex == 2){
    simulation.stop()
    d3.json('data_rainfall.txt', initialize)
    }
}

function initialize(error, data) {
    if (error) { throw error }

    var nodes = data.nodes
    var links = data.links

    size2.domain([0, d3.max(nodes, function (d) {
        return d3.max(d[variable2], function (e) { return e[mesure] })
    })])

    nodes.forEach(function (d) {
        var coords = projection2([d.lon, d.lat])
        d.x = d.xi = coords[0]
        d.y = d.yi = coords[1]
    })

    var states = svg.selectAll('.state')
        .data(nodes)
        .enter().append('g')
        .attr('class', 'state')

    states.append('rect').attr('class', 'staterect')
    states.append('text')
        .attr('text-anchor', 'middle')
        .attr('dy', '.3em')
        .text(function (d) { return d.state })
    simulation2.nodes(nodes)
    simulation2.force('link').links(links)
    simulation2.on('tick', ticked)

    update()
    d3.interval(update, interval)

    function update() {
        year2 = years2[++yearIndex2 >= years2.length ? yearIndex2 = 0 : yearIndex2]

        yearLabel2.text(year2)

        if (yearIndex2 === 0) { nodes.forEach(function (d) { d.x = d.xi; d.y = d.yi }) }

        simulation2.nodes(nodes).alpha(1).restart()
    }

    function ticked() {
        var sizes = d3.local()

        states
            .property(sizes, function (d) {
                return size2(d[variable2].find(function (e) { return e.year === year2 })[mesure])
            })
            .attr('transform', function (d) { return 'translate(' + d.x + ',' + d.y + ')' })
            

        states.selectAll('rect')
            .attr('x', function (d) { return sizes.get(this) / -2.08 })
            .attr('y', function (d) { return sizes.get(this) / -2 })
            .attr('width', function (d) { return sizes.get(this) })
            .attr('height', function (d) { return sizes.get(this) })
        		.style("fill", function(d) {
                //on prend la valeur recupere plus haut
                var value = d.population.find(function (e) { return e.year === year2 }).var;


                if (value) {
                    return color(value );
                } else { 
                    // si pas de valeur alors en gris
                    return "#ccc";
                }
            })
    }
}

  
  
function rectCollide() {
    var nodes, sizes, masses
    var size = constant([0, 0])
    var strength = 1
    var iterations = 1

    function force() {
        var node, size, mass, xi, yi
        var i = -1
        while (++i < iterations) { iterate() }

        function iterate() {
            var j = -1
            var tree = d3.quadtree(nodes, xCenter, yCenter).visitAfter(prepare)

            while (++j < nodes.length) {
                node = nodes[j]
                size = sizes[j]
                mass = masses[j]
                xi = xCenter(node)
                yi = yCenter(node)

                tree.visit(apply)
            }
        }

        function apply(quad, x0, y0, x1, y1) {
            var data = quad.data
            var xSize = (size[0] + quad.size[0]) / 2
            var ySize = (size[1] + quad.size[1]) / 2
            if (data) {
                if (data.index <= node.index) { return }

                var x = xi - xCenter(data)
                var y = yi - yCenter(data)
                var xd = Math.abs(x) - xSize
                var yd = Math.abs(y) - ySize

                if (xd < 0 && yd < 0) {
                    var l = Math.sqrt(x * x + y * y)
                    var m = masses[data.index] / (mass + masses[data.index])

                    if (Math.abs(xd) < Math.abs(yd)) {
                        node.vx -= (x *= xd / l * strength) * m
                        data.vx += x * (1 - m)
                    } else {
                        node.vy -= (y *= yd / l * strength) * m
                        data.vy += y * (1 - m)
                    }
                }
            }

            return x0 > xi + xSize || y0 > yi + ySize ||
                   x1 < xi - xSize || y1 < yi - ySize
        }

        function prepare(quad) {
            if (quad.data) {
                quad.size = sizes[quad.data.index]
            } else {
                quad.size = [0, 0]
                var i = -1
                while (++i < 4) {
                    if (quad[i] && quad[i].size) {
                        quad.size[0] = Math.max(quad.size[0], quad[i].size[0])
                        quad.size[1] = Math.max(quad.size[1], quad[i].size[1])
                    }
                }
            }
        }
    }

    function xCenter(d) { return d.x + d.vx }
    function yCenter(d) { return d.y + d.vy }

    force.initialize = function (_) {
        sizes = (nodes = _).map(size)
        masses = sizes.map(function (d) { return d[0] * d[1] })
    }

    force.size = function (_) {
        return (arguments.length
             ? (size = typeof _ === 'function' ? _ : constant(_), force)
             : size)
    }

    force.strength = function (_) {
        return (arguments.length ? (strength = +_, force) : strength)
    }

    force.iterations = function (_) {
        return (arguments.length ? (iterations = +_, force) : iterations)
    }

    return force
}

function constant(_) {
    return function () { return _ }
}
</script>
    </div>



    <div id="Page2" class="page" style="display:none">
<p>RAINFALL</p>

<script src="https://d3js.org/d3.v4.min.js"></script>  
<script>
var variable3 = 'Rainfall'
var interval = 2000
var maxSize = 123
  
var width = 981
var height = 508
var svg = d3.select('#Page2').append('svg')
    			.attr('width', width)
    			.attr('height', height)
    			.append('g') 

//L'ensemble des dates sur lesquelles seront récupérées les valeurs dans le json
var years3 = ['2008-été', '2009-automne', '2009-hiver',
       '2009-printemps', '2009-été', '2010-automne', '2010-hiver',
       '2010-printemps', '2010-été', '2011-automne', '2011-hiver',
       '2011-printemps', '2011-été', '2012-automne', '2012-hiver',
       '2012-printemps', '2012-été', '2013-automne', '2013-hiver',
       '2013-printemps', '2013-été', '2014-automne', '2014-hiver',
       '2014-printemps', '2014-été', '2015-automne', '2015-hiver',
       '2015-printemps', '2015-été', '2016-automne', '2016-hiver',
       '2016-printemps', '2016-été', '2017-automne', '2017-hiver',
       '2017-été']
var yearIndex3 = -1
var year3 = years3[0]    

//Définition des couleurs pour le remplissage des rectangles selon la densité de pop
var color = d3.scaleLinear().range(['#fee08b', '#d73027'])

//Définition de la projection, la map sur laquelle seront adaptées les coordonnées des territoires australiens
var projection3 = d3.geoConicConformal()
        .rotate([-132, 0])
        .center([0, -27])
        .parallels([-18, -36])
        .scale(Math.min(height * 1.2, width * 0.8))
        .translate([width / 2, height / 2])
        .precision(0.1);

//Taille des rectangles
var size3 = d3.scaleSqrt().range([0, maxSize])

//La date qui est  écrite sur la visualisation
var yearLabel3 = svg.append('text')
    .attr('class', 'year')
    .attr('x', width / 4.8)
    .attr('y', 29)
    .attr('text-anchor', 'middle')   


var mesure = 'var'  
  
//Définit la taille des links entre nodes (distance entre les rectangles)
var linkForce3 = d3.forceLink()
    .id(function (d) { return d.state })
    .distance(function (d) {
        return (
            size3(d.source[variable3].find(function (e) { return e.year === year3 })[mesure]) +
            size3(d.target[variable3].find(function (e) { return e.year === year3 })[mesure])
        ) / 1.6416
    })
    .strength(0.6)
    
//Collision entre les rectangles
var collisionForce3 = rectCollide()
    .size(function (d) {
        var l = size3(d[variable3].find(function (e) { return e.year === year3 })[mesure])
        return [l, l]
    })
    .iterations(63)

//Définition des paramètres de simulation
var simulation3 = d3.forceSimulation()
    .force('center', d3.forceCenter(width / 2.0608, (height - maxSize) / 2))
    .force('link', linkForce3)
    .force('collision', collisionForce3)
    .force('x', d3.forceX(function (d) { return d.xi }).strength(0.0125))
    .force('y', d3.forceY(function (d) { return d.yi }).strength(0.0125))

color.domain([0, 1219]);

//Si un autre item est sélectionné appel de la fonction change
d3.select("#label-option").on("change", change)

//Modifie la variable d'étude (température, humidity ou rainfall) de la fonction simulation

d3.json('data_rainfall.txt', initialize)

function change() {
    if (this.selectedIndex == 0){
    simulation.stop()
    d3.json('data_temperature.txt', initialize)
    } else if (this.selectedIndex == 1){
    simulation.stop()
    d3.json('data_humidity', initialize)
    } else if (this.selectedIndex == 2){
    simulation.stop()
    d3.json('data_rainfall.txt', initialize)
    }
}

function initialize(error, data) {
    if (error) { throw error }

    var nodes = data.nodes
    var links = data.links

    size3.domain([0, d3.max(nodes, function (d) {
        return d3.max(d[variable3], function (e) { return e[mesure] })
    })])

    nodes.forEach(function (d) {
        var coords = projection3([d.lon, d.lat])
        d.x = d.xi = coords[0]
        d.y = d.yi = coords[1]
    })

    var states = svg.selectAll('.state')
        .data(nodes)
        .enter().append('g')
        .attr('class', 'state')

    states.append('rect').attr('class', 'staterect')
    states.append('text')
        .attr('text-anchor', 'middle')
        .attr('dy', '.3em')
        .text(function (d) { return d.state })
    simulation3.nodes(nodes)
    simulation3.force('link').links(links)
    simulation3.on('tick', ticked)

    update()
    d3.interval(update, interval)

    function update() {
        year3 = years3[++yearIndex3 >= years3.length ? yearIndex3 = 0 : yearIndex3]

        yearLabel3.text(year3)

        if (yearIndex3 === 0) { nodes.forEach(function (d) { d.x = d.xi; d.y = d.yi }) }

        simulation3.nodes(nodes).alpha(1).restart()
    }

    function ticked() {
        var sizes = d3.local()

        states
            .property(sizes, function (d) {
                return size3(d[variable3].find(function (e) { return e.year === year3 })[mesure])
            })
            .attr('transform', function (d) { return 'translate(' + d.x + ',' + d.y + ')' })
            

        states.selectAll('rect')
            .attr('x', function (d) { return sizes.get(this) / -2.08 })
            .attr('y', function (d) { return sizes.get(this) / -2 })
            .attr('width', function (d) { return sizes.get(this) })
            .attr('height', function (d) { return sizes.get(this) })
        		.style("fill", function(d) {
                //on prend la valeur recupere plus haut
                var value = d.population.find(function (e) { return e.year === year3 }).var;


                if (value) {
                    return color(value );
                } else { 
                    // si pas de valeur alors en gris
                    return "#ccc";
                }
            })
    }
}

  
  
function rectCollide() {
    var nodes, sizes, masses
    var size = constant([0, 0])
    var strength = 1
    var iterations = 1

    function force() {
        var node, size, mass, xi, yi
        var i = -1
        while (++i < iterations) { iterate() }

        function iterate() {
            var j = -1
            var tree = d3.quadtree(nodes, xCenter, yCenter).visitAfter(prepare)

            while (++j < nodes.length) {
                node = nodes[j]
                size = sizes[j]
                mass = masses[j]
                xi = xCenter(node)
                yi = yCenter(node)

                tree.visit(apply)
            }
        }

        function apply(quad, x0, y0, x1, y1) {
            var data = quad.data
            var xSize = (size[0] + quad.size[0]) / 2
            var ySize = (size[1] + quad.size[1]) / 2
            if (data) {
                if (data.index <= node.index) { return }

                var x = xi - xCenter(data)
                var y = yi - yCenter(data)
                var xd = Math.abs(x) - xSize
                var yd = Math.abs(y) - ySize

                if (xd < 0 && yd < 0) {
                    var l = Math.sqrt(x * x + y * y)
                    var m = masses[data.index] / (mass + masses[data.index])

                    if (Math.abs(xd) < Math.abs(yd)) {
                        node.vx -= (x *= xd / l * strength) * m
                        data.vx += x * (1 - m)
                    } else {
                        node.vy -= (y *= yd / l * strength) * m
                        data.vy += y * (1 - m)
                    }
                }
            }

            return x0 > xi + xSize || y0 > yi + ySize ||
                   x1 < xi - xSize || y1 < yi - ySize
        }

        function prepare(quad) {
            if (quad.data) {
                quad.size = sizes[quad.data.index]
            } else {
                quad.size = [0, 0]
                var i = -1
                while (++i < 4) {
                    if (quad[i] && quad[i].size) {
                        quad.size[0] = Math.max(quad.size[0], quad[i].size[0])
                        quad.size[1] = Math.max(quad.size[1], quad[i].size[1])
                    }
                }
            }
        }
    }

    function xCenter(d) { return d.x + d.vx }
    function yCenter(d) { return d.y + d.vy }

    force.initialize = function (_) {
        sizes = (nodes = _).map(size)
        masses = sizes.map(function (d) { return d[0] * d[1] })
    }

    force.size = function (_) {
        return (arguments.length
             ? (size = typeof _ === 'function' ? _ : constant(_), force)
             : size)
    }

    force.strength = function (_) {
        return (arguments.length ? (strength = +_, force) : strength)
    }

    force.iterations = function (_) {
        return (arguments.length ? (iterations = +_, force) : iterations)
    }

    return force
}

function constant(_) {
    return function () { return _ }
}
</script>

    </div>
    <div id="Page3" class="page" style="display:none">
<p>TEMPERATURE</p>

<script src="https://d3js.org/d3.v4.min.js"></script>  
<script>
var variable1 = 'temperature'
var interval = 2000
var maxSize = 123
  
var width = 981
var height = 508
var svg = d3.select('#Page3').append('svg')
    			.attr('width', width)
    			.attr('height', height)
    			.append('g') 

//L'ensemble des dates sur lesquelles seront récupérées les valeurs dans le json
var years1 = ['2008-été', '2009-automne', '2009-hiver',
       '2009-printemps', '2009-été', '2010-automne', '2010-hiver',
       '2010-printemps', '2010-été', '2011-automne', '2011-hiver',
       '2011-printemps', '2011-été', '2012-automne', '2012-hiver',
       '2012-printemps', '2012-été', '2013-automne', '2013-hiver',
       '2013-printemps', '2013-été', '2014-automne', '2014-hiver',
       '2014-printemps', '2014-été', '2015-automne', '2015-hiver',
       '2015-printemps', '2015-été', '2016-automne', '2016-hiver',
       '2016-printemps', '2016-été', '2017-automne', '2017-hiver',
       '2017-été']
var yearIndex1 = -1
var year1 = years1[0]    

//Définition des couleurs pour le remplissage des rectangles selon la densité de pop
var color = d3.scaleLinear().range(['#fee08b', '#d73027'])

//Définition de la projection, la map sur laquelle seront adaptées les coordonnées des territoires australiens
var projection1 = d3.geoConicConformal()
        .rotate([-132, 0])
        .center([0, -27])
        .parallels([-18, -36])
        .scale(Math.min(height * 1.2, width * 0.8))
        .translate([width / 2, height / 2])
        .precision(0.1);

//Taille des rectangles
var size1 = d3.scaleSqrt().range([0, maxSize])

//La date qui est  écrite sur la visualisation
var yearLabel1 = svg.append('text')
    .attr('class', 'year')
    .attr('x', width / 4.8)
    .attr('y', 29)
    .attr('text-anchor', 'middle')   


var mesure = 'var'  
  
//Définit la taille des links entre nodes (distance entre les rectangles)
var linkForce1 = d3.forceLink()
    .id(function (d) { return d.state })
    .distance(function (d) {
        return (
            size1(d.source[variable1].find(function (e) { return e.year === year1 })[mesure]) +
            size1(d.target[variable1].find(function (e) { return e.year === year1 })[mesure])
        ) / 1.6416
    })
    .strength(0.6)
    
//Collision entre les rectangles
var collisionForce1 = rectCollide()
    .size(function (d) {
        var l = size1(d[variable1].find(function (e) { return e.year === year1 })[mesure])
        return [l, l]
    })
    .iterations(63)

//Définition des paramètres de simulation
var simulation1 = d3.forceSimulation()
    .force('center', d3.forceCenter(width / 2.0608, (height - maxSize) / 2))
    .force('link', linkForce1)
    .force('collision', collisionForce1)
    .force('x', d3.forceX(function (d) { return d.xi }).strength(0.0125))
    .force('y', d3.forceY(function (d) { return d.yi }).strength(0.0125))

color.domain([0, 1219]);

//Si un autre item est sélectionné appel de la fonction change
d3.select("#label-option").on("change", change)

//Modifie la variable d'étude (température, humidity ou rainfall) de la fonction simulation

d3.json('data_temperature.txt', initialize)

function change() {
    if (this.selectedIndex == 0){
    simulation.stop()
    d3.json('data_temperature.txt', initialize)
    } else if (this.selectedIndex == 1){
    simulation.stop()
    d3.json('data_humidity', initialize)
    } else if (this.selectedIndex == 2){
    simulation.stop()
    d3.json('data_rainfall.txt', initialize)
    }
}

function initialize(error, data) {
    if (error) { throw error }

    var nodes = data.nodes
    var links = data.links

    size1.domain([0, d3.max(nodes, function (d) {
        return d3.max(d[variable1], function (e) { return e[mesure] })
    })])

    nodes.forEach(function (d) {
        var coords = projection1([d.lon, d.lat])
        d.x = d.xi = coords[0]
        d.y = d.yi = coords[1]
    })

    var states = svg.selectAll('.state')
        .data(nodes)
        .enter().append('g')
        .attr('class', 'state')

    states.append('rect').attr('class', 'staterect')
    states.append('text')
        .attr('text-anchor', 'middle')
        .attr('dy', '.3em')
        .text(function (d) { return d.state })
    simulation1.nodes(nodes)
    simulation1.force('link').links(links)
    simulation1.on('tick', ticked)

    update()
    d3.interval(update, interval)

    function update() {
        year1 = years1[++yearIndex1 >= years1.length ? yearIndex1 = 0 : yearIndex1]

        yearLabel1.text(year1)

        if (yearIndex1 === 0) { nodes.forEach(function (d) { d.x = d.xi; d.y = d.yi }) }

        simulation1.nodes(nodes).alpha(1).restart()
    }

    function ticked() {
        var sizes = d3.local()

        states
            .property(sizes, function (d) {
                return size1(d[variable1].find(function (e) { return e.year === year1 })[mesure])
            })
            .attr('transform', function (d) { return 'translate(' + d.x + ',' + d.y + ')' })
            

        states.selectAll('rect')
            .attr('x', function (d) { return sizes.get(this) / -2.08 })
            .attr('y', function (d) { return sizes.get(this) / -2 })
            .attr('width', function (d) { return sizes.get(this) })
            .attr('height', function (d) { return sizes.get(this) })
        		.style("fill", function(d) {
                //on prend la valeur recupere plus haut
                var value = d.population.find(function (e) { return e.year === year1 }).var;


                if (value) {
                    return color(value );
                } else { 
                    // si pas de valeur alors en gris
                    return "#ccc";
                }
            })
    }
}

  
  
function rectCollide() {
    var nodes, sizes, masses
    var size = constant([0, 0])
    var strength = 1
    var iterations = 1

    function force() {
        var node, size, mass, xi, yi
        var i = -1
        while (++i < iterations) { iterate() }

        function iterate() {
            var j = -1
            var tree = d3.quadtree(nodes, xCenter, yCenter).visitAfter(prepare)

            while (++j < nodes.length) {
                node = nodes[j]
                size = sizes[j]
                mass = masses[j]
                xi = xCenter(node)
                yi = yCenter(node)

                tree.visit(apply)
            }
        }

        function apply(quad, x0, y0, x1, y1) {
            var data = quad.data
            var xSize = (size[0] + quad.size[0]) / 2
            var ySize = (size[1] + quad.size[1]) / 2
            if (data) {
                if (data.index <= node.index) { return }

                var x = xi - xCenter(data)
                var y = yi - yCenter(data)
                var xd = Math.abs(x) - xSize
                var yd = Math.abs(y) - ySize

                if (xd < 0 && yd < 0) {
                    var l = Math.sqrt(x * x + y * y)
                    var m = masses[data.index] / (mass + masses[data.index])

                    if (Math.abs(xd) < Math.abs(yd)) {
                        node.vx -= (x *= xd / l * strength) * m
                        data.vx += x * (1 - m)
                    } else {
                        node.vy -= (y *= yd / l * strength) * m
                        data.vy += y * (1 - m)
                    }
                }
            }

            return x0 > xi + xSize || y0 > yi + ySize ||
                   x1 < xi - xSize || y1 < yi - ySize
        }

        function prepare(quad) {
            if (quad.data) {
                quad.size = sizes[quad.data.index]
            } else {
                quad.size = [0, 0]
                var i = -1
                while (++i < 4) {
                    if (quad[i] && quad[i].size) {
                        quad.size[0] = Math.max(quad.size[0], quad[i].size[0])
                        quad.size[1] = Math.max(quad.size[1], quad[i].size[1])
                    }
                }
            }
        }
    }

    function xCenter(d) { return d.x + d.vx }
    function yCenter(d) { return d.y + d.vy }

    force.initialize = function (_) {
        sizes = (nodes = _).map(size)
        masses = sizes.map(function (d) { return d[0] * d[1] })
    }

    force.size = function (_) {
        return (arguments.length
             ? (size = typeof _ === 'function' ? _ : constant(_), force)
             : size)
    }

    force.strength = function (_) {
        return (arguments.length ? (strength = +_, force) : strength)
    }

    force.iterations = function (_) {
        return (arguments.length ? (iterations = +_, force) : iterations)
    }

    return force
}

function constant(_) {
    return function () { return _ }
}

</script>
    </div>
    







    <div id="map-top" class="block">
    <div class="title">Left chart</div>
  </div>
  <div id="chart-bottom" class="block">
    <div class="title">Right chart</div>
  </div>
  
  
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script>
    // Dimensions
    var margins = {top:30, bottom:30, left:30, right:30}
    var width = 430 - margins.left - margins.right;
    var height = 400 - margins.top - margins.bottom;
    
    arrayTest = [10, 12, 4, 8, 10, 2, 0, 10, 20];
    
    // Svg of map
    var svg = d3.select("#map-top").append("svg")
      .attr("width", width + margins.left + margins.right)
      .attr("height", height + margins.bottom + margins.top)
    
    var g_map = svg.append('g')
    	.attr("transform", "translate(" + margins.left + "," + margins.top + ")")
    
    var x = d3.scaleLinear()
    	.range([0,width]),
        y = d3.scaleLinear()
    	.range([height, 0])
    
    // Svg of chart
    var svg_chart = d3.select("#chart-bottom").append("svg")
    	.attr("width", width + margins.left + margins.right)
    	.attr("height", height + margins.bottom + margins.top)
    
    var g_chart = svg_chart.append('g')
    	.attr("transform", "translate(" + margins.left + "," + margins.top + ")");
    
    var x_axis = d3.scaleTime()
    	.range([0, width])
    
    var x_chart = d3.scaleLinear()
    	.range([0, width])
    
    var y_chart = d3.scaleLinear()
    	.range([height, 0])
    
    // Axis
    var xAxis = d3.axisBottom()
      .scale(x_axis)

  	var yAxis = d3.axisLeft()
      .scale(y_chart)
    
    // Plot l'axe X
    d3.csv('weatherAUS_agg.csv', function(data){
      // Date formats
      var parseDate = d3.timeParse("%Y-%m");
      var displayDate = d3.timeFormat("%Y")
    
      // Column of dates
      var dates = data.map(function(value,index) { return displayDate(parseDate(value['date_months']));})
			
      // Annees min et max
      x_axis.domain([d3.min(dates), d3.max(dates)])

      // xAxis
      g_chart.append('g')
        .attr('transform', 'translate(0,' + height + ')')
        .attr('class', 'xaxis')
        .call(xAxis)
    })
    
    // Colors
    var colormap = d3.scaleOrdinal(d3.schemeCategory20);
    
    // Projection : a modifier pour changer la carte (taille, position etc...)
    var projection = d3.geoMercator()
    .translate([ width/2, height/2 ])
    .scale(500)
    .center([ 132, -28 ])

    // Path
    var path = d3.geoPath().projection(projection);
    
    // Load the map
    d3.json("aust.json", function(json){
      // Un 'g' pour chaque etat
      var group = g_map.selectAll('.map').data(json.features)
      	.enter().append('g').attr('class', 'map');
      // Un 'path' dans chaque 'g'
      var regions = group.append('path')
      	.attr('d', path)
      	.attr('class', 'area')
    })
    
    
    // Fonction appelée lors d'un changement de variable par les boutons radios
    // Appelée au debut avec la variable MinTemp
      function changeVariable(v){
      varToPlot = v;
      console.log(varToPlot)
      
      // Supprime l'ancien axe
      d3.selectAll('.yaxis').remove()
      d3.csv('weatherAUS_agg.csv', function(data){

        // Get one variable of all array
        var column = data.map(function(value,index) { return parseFloat(value[varToPlot]);})
				
        // Domaine de la variable
        y_chart.domain([0, d3.max(column)]).nice()
        
        // Rajoute l'axe des y
        g_chart.append('g')
          .attr('transform', 'translate(0,0)')
          .attr('class', 'yaxis')
          .call(yAxis);
        
      })
    }
    changeVariable('MinTemp');
    
    // Enleve le plot d'une station (une ligne)
    function removePlot(Station){
      g_chart.selectAll('#' + Station).remove()
    }
    
    // Plot chart (appelée lors d'une selection par le brush)
    function plotChart(Station, col){
      d3.csv('weatherAUS_agg.csv', function(data){
        
        // Get the data of just one station
				oneStation = []
        data.forEach(function(d){
        	if(d.Location == Station){
            oneStation.push(d)
          }
        })
        lineChart(oneStation, col, Station)
      })
    }
    
    // Plot lineChart
    function lineChart(array, col, Station){
      console.log(Station)
      // 113 est le nombre de valeur max pour une ville
      x_chart.domain([0, 113]) 
      
      var line = d3.line()
      	.x(function(d, i){ return x_chart(i)})
      	.y(function(d){ return y_chart(d[varToPlot])})
      
      // CREATE
      g_chart.selectAll('#' + Station)
      	.data([array]).enter().append("path")
      	.attr('class', 'line')
      	.attr('id', Station)
      	.attr('d', line)
      	.attr('stroke', col)
      	.attr('fill', col)
      
      // UPDATE 
      /*
      g_chart.selectAll('#' + Station).data([array])
      			.transition().delay(function(d, i) { return i * 10; })
      			.attr('class', 'line')
            .attr('station', Station)
            .attr('d', line)
            .attr('stroke', col)
            .attr('fill', col)
            */
      
      
      // SUPPRESSION
      g_chart.selectAll('#' + Station).data([array])
      	.exit()
				.remove() 
    }
    
    // Load cities coordinates
    d3.csv('Cities.csv', function(csv){
        csv.forEach(function(d){
          d.Latitude = +d.Latitude
          d.Longitude = +d.Longitude
        })
        
        // Un g pour chaque ville
        gcities = g_map.selectAll('.city')
          .data(csv).enter().append('g')
        	.attr('class', 'city')
        	.text(function(d){return d.Station})
        
        console.log(2)
        circles = gcities.append('circle')
        	.attr('class', 'non_brushed')
        	.attr('r', 6)
        	.attr('cx', function(d){return projection([d.Longitude, d.Latitude])[0]})
        	.attr('cy', function(d){return projection([d.Longitude, d.Latitude])[1]})
        	.attr('fill', function(d,i){
          return colormap(i)})
        	/*
        	.on("mouseover", function(d,i){
            return tooltip.style("visibility", "visible")
              .text(function(){return d.Station})
        	})
          .on("mousemove", function(){return tooltip.style("top",
              (d3.event.pageY-10)+"px").style("left",(d3.event.pageX+10)+"px");})
          .on("mouseout", function(){return tooltip.style("visibility","hidden");}); */
       

        
      })
    
    // Tooltip pour les villes
    var tooltip = d3.select("body")
      .append("div")
      .style("position", "absolute")
      .style("z-index", "10")
      .style("visibility", "hidden")
    
    // Brush
    var brush = d3.brush()
    .extent([[0, 0], [(width+margins.left), (height+margins.bottom)]])
    .on("brush", brushed)
    .on("end", brushend);
    
    // Create brush function redraw scatterplot with selection
    function brushed() {
      if (d3.event.selection != null){
        
        var selection = d3.event.selection;
        // Position de la selection
        var x0 = selection[0][0],
            y0 = selection[0][1],
            x1 = selection[1][0],
            y1 = selection[1][1];
        
        // Met les cercles de la selection en "brushed" et appelle la fct de plot
        circles.filter(function(){
          return d3.select(this).attr('class', 'non_brushed')})
        	.attr('class', function(d,i){
          var cx = d3.select(this).attr("cx"),
              cy = d3.select(this).attr("cy");
          if(x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1){
            // Call plot function
            plotChart(d.Station, colormap(i))
						tooltip.style("visibility", "visible")
              .text(function(){return d.Station})
            return 'brushed'
          } else{
            removePlot(d.Station)
            return 'non_brushed'
          } })
        
      }
		}
    
    function brushend() {
      	
      if (!d3.event.selection) {
        svg.selectAll('circle')
          .transition()
          .duration(1)
          .ease(d3.easeLinear)
          .attr("class", "non_brushed");
      }
     }
    
    // Append the brush in a g object in the map
    svg.append("g")
    	.attr("transform", "translate(" + margins.left + "," + margins.top + ")")
      .attr("class", "x brush")
      .call(brush)  //call the brush function, causing it to create the rectangles
    .selectAll("rect") //select all the just-created rectangles
      .attr("y", -6)
      .attr("height", height + 7); //set their height
    
    
    

  </script>

    </body>
</html>
